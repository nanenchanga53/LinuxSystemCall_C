쉘 명령
복합 명령 쉘
- 전면 처리
	명령어가 전면에서 실행되며 명령어 실행이 끝날 때까지 쉘이 기다림
- 후면 처리
	명령어를 후면에서 처리하여 전면에서 다른 작업을 할 수 있음(전면처리와 다르게 표준 입력을 받을 수 없음)



(sleep 100; echo done) & //100초 뒤 완료를 알려라
find . -name test.c -print & //test.c를 찾고 출력
jobs //현재 실행되고 있는것을 출력
fg %작업번호  //작업되고 있는것
후면처리 입출력 (뒤에 &을 붙이면 후면처리한다)
find . -name test.c -print > find.txt &


프로세스 명령어
ps -ef //현재 존재하는 프로세스들의 실행 상태를 요약해서 출력
sleep 초   혹은  (echo 시작; sleep 5; echo 끝) //지정되 시간만큼 실행을 중지
kill [-시그널] 프로세스 번호 //현제 실행중인 프로세스를 강제종료
wait 프로세스번호 //해당 프로세스 번호를 갖는 자식 프로세스가 종료될때까지 대기
exit 종료코드 //쉘을 종료하고 종료코드를 부모 프로세스에 전달



C 시작 루틴
main 함수를 호출하면서 명령줄 인수, 환경 변수를 전달 exit(main(argc,argv)); -> 실행이 끝나면 반환값을 받아 exit
int main(int argc, char *argv[]);
argc; 명령줄 인수의 개수
argv[] : 명령줄 인수 리스트를 나타내는 포인터 배열


프로세스 종료
- 정상종료 exit() // 버퍼내용을 디스크에 쓰는 (fflush)등의 뒷정리 후 프로세스를 정상적으로 종료
- 비정상 종료 abort() // 프로세스에 SIGABRT 시그널을 보내어 프로세스를 비정상적으로 종료

atexit() //프로세스 정료 전 처리기에 등록(종료전 실행) 스택으로 저장되기때문에 나중에 선언된것이 먼저 실행되며 종료


fork //시스템호출(부모 프로세스를 복제하여 새로운 자식 프로세스를 생성)
wait //자식 프로세스 종료 대기
wait(&status) return 값 // 종료하는 자식의 pid
 - status : 자식이 exit으로 종료될 때의 상태정보 8BIT | 8Bit 로 돌아온다
   - 정상종료 경우 : 하위 8bit는 0 상위 8bits는 exit status
   - signal 종료 : 하위 8bits는 signal 번호, 상위 8bits는 0


exec() // 시스템 호출을 사용하여 프로세스 내의 프로그램을 새 프로그램으로 대치시킴(fork로 만든 프로세스를 새로운 프로그램으로 바꾼다고 생각하자)

프로세스 그룹 : 부모 프로세스가 생성하는 자식 프로세스들은 부모와 같은 프로세스 그룹에 속한다. fork()시 상속
pid_t getpgrp(void);

pid == pgid // 새로운 그룹 리더 setpgid(0,0) 0번의 새로운 리더
pid != pgid //다른 그룹의 멤버 setpid(0,1000) 1000번의 멤버
pid == 0 // 호출자의 PID 사용
pgid == 0 // 새로운 그룹 리더가 됨


